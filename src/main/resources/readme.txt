项目增加的知识点：
1、广播状态流
    流里面的数据直接保存到状态中。数据不能太多
    代码写到其他流的前面
    可以直接使用Rich函数替换
2、流计算中的TopN处理：
    1、针对窗口1触发之后的结果做TopN
        窗口1触发之后 --》 窗口2 来做TopN
    2、针对窗口中的所有的原始数据做TopN
        在窗口触发函数中做降序排序，然后TopN



思考题： 企业中有两种数据流（都比较大）
第一个流： 车辆违法信息
鲁H37985,涉嫌套牌车,1592515403000
鲁H37989,涉嫌套牌车,1592515412000
鲁H37984,涉嫌套牌车,1592515418000
鲁H37987,涉嫌套牌车,1592515417000
鲁H37999,涉嫌套牌车,1592515420000
第二流： 交警出警的记录数据
J0001,鲁H37988,处理完成,1592515412000
J0002,鲁H37985,处理完成,1592515404000
J0002,鲁H37987,处理完成,1592515426000
J0003,鲁H37999,处理完成,1592515430000
J0003,鲁H37922,处理完成,1592515418000


3、Flink和Hbase的Sink ，使用批量插入Hbase的表，
    注意：可以采用CountWindow来辅助批量写入。

4、布隆过滤器
    是一个二进制向量的数据结构
    [00000000000000......] 100亿的长度（根据去重的数据量和预估的容错几率） ，占用的内存空间大概500M
    Redis中有位图计算函数getbit和setbit


5、关于性能：
1、避免使用redis做位图计算 ： 解决办法，都实现序列化：JDK自带一个位图计算工具java.util.BiteSet  ,2、google提供了位图计算的工具：bloomFilter
2、不需要每一条数据去重都要输出一下，在窗口结束的时候输出




区域id:03,时间范围是,起始时间:1598768730000----结束时间:1598768760000,一共上路的车辆为106731
区域id:01,时间范围是,起始时间:1598768730000----结束时间:1598768760000,一共上路的车辆为106782
区域id:04,时间范围是,起始时间:1598768730000----结束时间:1598768760000,一共上路的车辆为106778
区域id:00,时间范围是,起始时间:1598768730000----结束时间:1598768760000,一共上路的车辆为106744
区域id:05,时间范围是,起始时间:1598768730000----结束时间:1598768760000,一共上路的车辆为106747
区域id:07,时间范围是,起始时间:1598768730000----结束时间:1598768760000,一共上路的车辆为106757
区域id:02,时间范围是,起始时间:1598768730000----结束时间:1598768760000,一共上路的车辆为106922
区域id:06,时间范围是,起始时间:1598768730000----结束时间:1598768760000,一共上路的车辆为106815